from django.shortcuts import render
from django.http.response import JsonResponse
from django.utils import timezone
from random import randint
from django.conf import settings
import os
import json
from .models import SensorData,  Alerta
from django.db.models import Avg, Min, Max
from django.core import serializers

from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt

CONFIG_PATH = 'main_menu/config/'
    
BASE_CHART_LINE_CONFIG = {
    'tooltip': {
        'trigger': 'axis'
    },
    'legend': {
        'top': 'bottom',
        'left': 0
    },
    'toolbox': {
        'top': 'bottom',
        'show': 'true',
        'feature': {
            'dataZoom': {
                'yAxisIndex': 'none'
            },
            'dataView': {'readOnly': 'false'},
            'magicType': {'type': ['line', 'bar']},
            'restore': {},
            'saveAsImage': {}
        }
    },
    'xAxis': {
        'type': 'category',
        'boundaryGap': 'false',
    },
    'yAxis': {
        'type': 'value',
    },
    'series': [
        {
            'type': 'line',
            'smooth': 'true',
            'markLine': {
                'data': [
                    {'type': 'average', 'name': 'Avg'},
                    [
                        {
                            'symbol': 'none',
                            'x': '90%',
                            'yAxis': 'max'
                        },
                        {
                            'symbol': 'circle',
                            'label': {
                                'position': 'start',
                                'formatter': 'Max'
                            },
                            'type': 'max',
                            'name': '最高点'
                        }
                    ]
                ]
            }
        }
    ]
}

@csrf_exempt  # Temporalmente para pruebas
@require_POST
def resolve_alert(request):
    try:
        data = json.loads(request.body)
        alert_id = data.get('alert_id')
        comment = data.get('comment', '') # Obtiene el comentario, o un string vacío si no se encuentra
        
        alert = Alerta.objects.get(pk=alert_id)
        alert.is_resolved = True
        alert.message = comment # ¡Guarda el comentario en el campo 'message'!
        alert.save()

        return JsonResponse({'success': True, 'message': 'Alerta resuelta correctamente.'})
    except Alerta.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Alerta no encontrada.'}, status=404)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

try:
    print("Abriendo: ",  os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json'))
    config_file_path = os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json')
    with open(config_file_path, 'r', encoding='utf-8') as f:
        GRAPH_CONFIG = json.load(f)
except FileNotFoundError:
    GRAPH_CONFIG = {}  
    print("Warning: config.json file not found. Graph configuration will be empty.")

try:
    config_file_path = os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json')
    with open(config_file_path, 'r', encoding='utf-8') as f:
        GRAPH_CONFIG = json.load(f)
except FileNotFoundError:
    GRAPH_CONFIG = {}
    print("Warning: config.json file not found. Graph configuration will be empty.")

SENSOR_CODE_MAP = {
    key: value['short_code'] for key, value in GRAPH_CONFIG.items()
}

def get_alerts_json(request):
    alerts = Alerta.objects.all().order_by('-timestamp')[:50]
    alerts_json_string = serializers.serialize('json', alerts, fields=('sensor_type', 'value', 'message', 'timestamp', 'is_resolved', 'id'))
    alerts_data = json.loads(alerts_json_string)
    return JsonResponse(alerts_data, safe=False)

def get_sensors_config(request):
    config_file_path = os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json')
    try:
        with open(config_file_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
            return JsonResponse(config_data)
    except FileNotFoundError:
        return JsonResponse({'error': 'Configuración de sensores no encontrada.'}, status=404)

def get_data_and_stats(sensor_name):
    
    sensor_code = SENSOR_CODE_MAP.get(sensor_name)
    if not sensor_code:
        return None 

    queryset = SensorData.objects.filter(sensor_type=sensor_code).order_by('timestamp')
    data_values = list(queryset.values_list('value', flat=True))
    data_dates = [d.strftime('%Y-%m-%d %H:%M:%S') for d in queryset.values_list('timestamp', flat=True)]
    stats = queryset.aggregate(avg_value=Avg('value'), min_value=Min('value'), max_value=Max('value'))

    return {
        'data_dates': data_dates, 
        'data_values': data_values, 
        'stats': stats
    }


def get_stats_json(request, model_name):
    stats_data = get_data_and_stats(model_name)
    if not stats_data:
        return JsonResponse({'error': f'Modelo "{model_name}" no encontrado.'}, status=404)

    return JsonResponse(stats_data['stats'])

def get_dynamic_graph(request, sensor_name):
    if sensor_name not in GRAPH_CONFIG:
        return JsonResponse({'error': f'Sensor {sensor_name} no encontrado.'}, status=404)

    config = GRAPH_CONFIG[sensor_name]
    
    data = get_data_and_stats(sensor_name)
    if not data:
        return JsonResponse({'error': f'Datos para el sensor "{sensor_name}" no encontrados.'}, status=404)

    chart = BASE_CHART_LINE_CONFIG.copy()
    chart['xAxis']['data'] = data['data_dates']
    chart['yAxis']['axisLabel'] = {'formatter': f'{{value}} {config["unit"]}'}
    chart['series'][0]['name'] = config['name']
    chart['series'][0]['color'] = config['color']
    chart['series'][0]['data'] = data['data_values']
    
    return JsonResponse(chart)

def main_menu(request):
    titulo = "AgriTech"
    alertas = Alerta.objects.all().order_by('-timestamp') 

    print("Abriendo: ",  os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json'))
    config_file_path = os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json')
    
    with open(config_file_path, 'r') as f:
        config_sensores = json.load(f)

    umbrales = {
        data['short_code']: {
            'min': data['threshold']['min'],
            'max': data['threshold']['max'],
            'unit': data['unit']
        }
        for data in config_sensores.values()
    }
    
    context = {
        'titulo' : titulo,
        'width': 'w-20',
        'alertas': alertas,
        'umbrales': umbrales,
        'breadcrumb_titulo': 'Alertas'
    }

    return render(request, 'index.html', context)

def set_chart():
    current_datetime = timezone.now()
    date_str = current_datetime.strftime('%H:%M')
    d = DataBaseTemperature(data_date=date_str, data_value=randint(10, 100))
    d.save()

def read_data_base(model):
    data_date = list(model.objects.values_list('data_date', flat=True))
    data_value = list(model.objects.values_list('data_value', flat=True))
    return data_date, data_value

def get_graph_pie(request):
    chart = {
        'tooltip': {
            'trigger': 'item'
        },
        'legend': {
            'orient': 'vertical',
            'left': 'left',
            'top': 'bottom'
        },
        'series': [
            {
                'name': 'Access From',
                'type': 'pie',
                'radius': '50%',
                'data': [
                    {'value': 1048, 'name': 'Nutrientes'},
                    {'value': 735, 'name': 'Fósforo'},
                    {'value': 580, 'name': 'Nitrogeno'},
                    {'value': 484, 'name': 'Minerales'},
                    {'value': 300, 'name': 'Potacio'}
                ],
                'emphasis': {
                    'itemStyle': {
                        'shadowBlur': 10,
                        'shadowOffsetX': 0,
                        'shadowColor': 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
    }
    return JsonResponse(chart)



@csrf_exempt
def add_sensor(request):

    print("Abriendo: ",  os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json'))
    config_file_path = os.path.join(settings.BASE_DIR, CONFIG_PATH, 'config.json')

    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            sensor_name_key = data['name'].lower().replace(" ", "_") # Ejemplo: 'Temperatura' -> 'temperatura'
            
            # Carga el archivo JSON actual
            with open(config_file_path, 'r+') as file:
                config_data = json.load(file)
            
            # Agrega el nuevo sensor
            config_data[sensor_name_key] = {
                "short_code": data['short_code'],
                "name": data['name'],
                "unit": data['unit'],
                "icon": data['icon'],
                "gradient": data['gradient'],
                "color": data['color'],
                "threshold": {
                    "min": data['threshold']['min'],
                    "max": data['threshold']['max']
                }
            }

            # Guarda el archivo JSON actualizado
            with open(config_file_path, 'w') as file:
                json.dump(config_data, file, indent=4)
            
            return JsonResponse({'success': True})
        
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})






def get_graph_large(request):
    colors = ['#5470C6', '#EE6666']
    chart = {
        'color': colors,
        'tooltip': {
            'trigger': 'none',
            'axisPointer': {
                'type': 'cross'
            }
        },
        'legend': {},
        'grid': {
            'top': 70,
            'bottom': 50
        },
        'xAxis': [
            {
                'type': 'category',
                'axisTick': {
                    'alignWithLabel': 'true'
                },
                'axisLine': {
                    'onZero': 'false',
                    'lineStyle': {
                        'color': colors[1]
                    }
                },
                'data': ['2016-1', '2016-2', '2016-3', '2016-4', '2016-5', '2016-6', '2016-7', '2016-8', '2016-9', '2016-10', '2016-11', '2016-12']
            },
            {
                'type': 'category',
                'axisTick': {
                    'alignWithLabel': 'true'
                },
                'axisLine': {
                    'onZero': 'false',
                    'lineStyle': {
                        'color': colors[0]
                    }
                },
                'data': ['2015-1', '2015-2', '2015-3', '2015-4', '2015-5', '2015-6', '2015-7', '2015-8', '2015-9', '2015-10', '2015-11', '2015-12']
            }
        ],
        'yAxis': [
            {
                'type': 'value'
            }
        ],
        'series': [
            {
                'name': 'Precipitation(2015)',
                'type': 'line',
                'xAxisIndex': 1,
                'smooth': 'true',
                'emphasis': {
                    'focus': 'series'
                },
                'data': [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3]
            },
            {
                'name': 'Precipitationes(2023)',
                'type': 'line',
                'smooth': 'true',
                'emphasis': {
                    'focus': 'series'
                },
                'data': [3.9, 5.9, 11.1, 18.7, 48.3, 69.2, 231.6, 46.6, 55.4, 18.4, 10.3, 0.7]
            }
        ]
    }
    return JsonResponse(chart)
